<!DOCTYPE html><html class="default" lang="en"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>HotMesh</title><meta name="description" content="Documentation for @hotmeshio/hotmesh"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><link rel="stylesheet" href="assets/custom.css"/><script defer src="assets/main.js"></script><script async src="assets/icons.js" id="tsd-icons-script"></script><script async src="assets/search.js" id="tsd-search-script"></script><script async src="assets/navigation.js" id="tsd-nav-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search" data-base="."><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">HotMesh</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-panel tsd-typography"><a id="md:hotmesh" class="tsd-anchor"></a><h1 class="tsd-anchor-link">HotMesh<a href="#md:hotmesh" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h1><p><img src="https://img.shields.io/badge/release-beta-blue.svg" alt="beta release"></p>
<p><strong>HotMesh</strong> offers the power of <a href="https://temporal.io">Temporal.io</a> in a fully serverless architecture.</p>
<br/>
<a id="md:features" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Features<a href="#md:features" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><ul>
<li><strong>Serverless Orchestration</strong>: Orchestrate without adding infrastructure</li>
<li><strong>No Vendor Lock-in</strong>: Use your preferred database: <em>Postgres</em>, <em>Redis</em>, ...</li>
<li><strong>Linear Scalability</strong>: Scale your database to scale your application</li>
<li><strong>Process Analytics</strong>: Gain process insights with optional analytics</li>
</ul>
<br/>
<a id="md:install" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Install<a href="#md:install" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><pre><code class="sh"><span class="hl-0">npm</span><span class="hl-1"> </span><span class="hl-2">install</span><span class="hl-1"> </span><span class="hl-2">@hotmeshio/hotmesh</span>
</code><button type="button">Copy</button></pre>

<br/>
<a id="md:learn" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Learn<a href="#md:learn" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p><a href="https://hotmesh.io/">üè† Home</a> | <a href="https://hotmeshio.github.io/sdk-typescript/">üìÑ SDK Docs</a> | <a href="https://github.com/hotmeshio/samples-typescript">üíº General Examples</a> | <a href="https://github.com/hotmeshio/temporal-patterns-typescript">üíº Temporal Examples</a></p>
<br/>
<a id="md:meshcall--service-to-service-function-calls" class="tsd-anchor"></a><h2 class="tsd-anchor-link">MeshCall | Service-to-Service Function Calls<a href="#md:meshcall--service-to-service-function-calls" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p><a href="https://hotmeshio.github.io/sdk-typescript/classes/services_meshcall.MeshCall.html">MeshCall</a> connects your functions to the mesh.</p>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Run an idempotent cron job <small>[more]</small></summary>
<a id="md:run-a-cron" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Run a Cron<a href="#md:run-a-cron" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>This example demonstrates an <em>idempotent</em> cron that runs daily at midnight. The <code>id</code> makes each cron job unique and ensures that only one instance runs, despite repeated invocations. <em>The <code>cron</code> method returns <code>false</code> if a workflow is already running with the same <code>id</code>.</em></p>
<p>Optionally set a <code>delay</code> and/or set <code>maxCycles</code> to limit the number of cycles. The <code>interval</code> can be any human-readable time format (e.g., <code>1 day</code>, <code>2 hours</code>, <code>30 minutes</code>, etc) or a standard cron expression.</p>
<ol>
<li>
<p>Define the cron function.</p>
<pre><code class="typescript"><span class="hl-3">//cron.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">MeshCall</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">export</span><span class="hl-1"> </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-0">runMyCron</span><span class="hl-1"> = </span><span class="hl-6">async</span><span class="hl-1"> (</span><span class="hl-5">id</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">, </span><span class="hl-5">interval</span><span class="hl-1"> = </span><span class="hl-2">&#39;0 0 * * *&#39;</span><span class="hl-1">): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;</span><span class="hl-7">boolean</span><span class="hl-1">&gt; </span><span class="hl-6">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-4">return</span><span class="hl-1"> </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">MeshCall</span><span class="hl-1">.</span><span class="hl-0">cron</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">topic:</span><span class="hl-1"> </span><span class="hl-2">&#39;my.cron.function&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">      }</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-0">callback</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-6">async</span><span class="hl-1"> () </span><span class="hl-6">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-3">//your code here...</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> { </span><span class="hl-5">id</span><span class="hl-1">, </span><span class="hl-5">interval</span><span class="hl-1">, </span><span class="hl-5">maxCycles:</span><span class="hl-1"> </span><span class="hl-8">24</span><span class="hl-1"> }</span><br/><span class="hl-1">  });</span><br/><span class="hl-1">};</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Call <code>runMyCron</code> at server startup (or call as needed to run multiple crons).</p>
<pre><code class="typescript"><span class="hl-3">//server.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">runMyCron</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./cron&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-0">runMyCron</span><span class="hl-1">(</span><span class="hl-2">&#39;myNightlyCron123&#39;</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Interrupt a cron job <small>[more]</small></summary>
<a id="md:interrupt-a-cron" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Interrupt a Cron<a href="#md:interrupt-a-cron" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>This example demonstrates how to cancel a running cron job.</p>
<ol>
<li>Use the same <code>id</code> and <code>topic</code> that were used to create the cron to cancel it.<pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">MeshCall</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-5">MeshCall</span><span class="hl-1">.</span><span class="hl-0">interrupt</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-5">topic:</span><span class="hl-1"> </span><span class="hl-2">&#39;my.cron.function&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-5">options:</span><span class="hl-1"> { </span><span class="hl-5">id:</span><span class="hl-1"> </span><span class="hl-2">&#39;myNightlyCron123&#39;</span><span class="hl-1"> }</span><br/><span class="hl-1">});</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Call any function in any service <small>[more]</small></summary>
<a id="md:call-a-function" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Call a Function<a href="#md:call-a-function" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Make interservice calls that behave like HTTP but without the setup and performance overhead. This example demonstrates how to connect and call a function.</p>
<ol>
<li>
<p>Call <code>MeshCall.connect</code> and provide a <code>topic</code> to uniquely identify the function.</p>
<pre><code class="typescript"><span class="hl-3">//myFunctionWrapper.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">MeshCall</span><span class="hl-1">, </span><span class="hl-5">Types</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">export</span><span class="hl-1"> </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-0">connectMyFunction</span><span class="hl-1"> = </span><span class="hl-6">async</span><span class="hl-1"> () </span><span class="hl-6">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-4">return</span><span class="hl-1"> </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">MeshCall</span><span class="hl-1">.</span><span class="hl-0">connect</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">topic:</span><span class="hl-1"> </span><span class="hl-2">&#39;my.demo.function&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">      }</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-0">callback</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-6">async</span><span class="hl-1"> (</span><span class="hl-5">input</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">) </span><span class="hl-6">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-3">//your code goes here; response must be JSON serializable</span><br/><span class="hl-1">      </span><span class="hl-4">return</span><span class="hl-1"> { </span><span class="hl-5">hello:</span><span class="hl-1"> </span><span class="hl-5">input</span><span class="hl-1"> }</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">  });</span><br/><span class="hl-1">};</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Call <code>connectMyFunction</code> at server startup to connect your function to the mesh.</p>
<pre><code class="typescript"><span class="hl-3">//server.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">connectMyFunction</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./myFunctionWrapper&#39;</span><span class="hl-1">;</span><br/><span class="hl-0">connectMyFunction</span><span class="hl-1">();</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Call your function from anywhere on the network (or even from the same service). Send any payload as long as it's JSON serializable.</p>
<pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">MeshCall</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">result</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">MeshCall</span><span class="hl-1">.</span><span class="hl-0">exec</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-5">topic:</span><span class="hl-1"> </span><span class="hl-2">&#39;my.demo.function&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">args:</span><span class="hl-1"> [</span><span class="hl-2">&#39;something&#39;</span><span class="hl-1">],</span><br/><span class="hl-1">  </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">}); </span><span class="hl-3">//returns `{ hello: &#39;something&#39;}`</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Call and <b>cache</b> a function <small>[more]</small></summary>
<a id="md:cache-a-function" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Cache a Function<a href="#md:cache-a-function" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>This solution builds upon the previous example, caching the response. The linked function will only be re/called when the cached result expires. Everything remains the same, except the caller which specifies an <code>id</code> and <code>ttl</code>.</p>
<ol>
<li>
<p>Make the call from another service (or even the same service). Include an <code>id</code> and <code>ttl</code> to cache the result for the specified duration.</p>
<pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">MeshCall</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">result</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">MeshCall</span><span class="hl-1">.</span><span class="hl-0">exec</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-5">topic:</span><span class="hl-1"> </span><span class="hl-2">&#39;my.demo.function&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">args:</span><span class="hl-1"> [</span><span class="hl-2">&#39;anything&#39;</span><span class="hl-1">],</span><br/><span class="hl-1">  </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-5">options:</span><span class="hl-1"> { </span><span class="hl-5">id:</span><span class="hl-1"> </span><span class="hl-2">&#39;myid123&#39;</span><span class="hl-1">, </span><span class="hl-5">ttl:</span><span class="hl-1"> </span><span class="hl-2">&#39;15 minutes&#39;</span><span class="hl-1"> },</span><br/><span class="hl-1">}); </span><span class="hl-3">//returns `{ hello: &#39;anything&#39;}`</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Flush the cache at any time, using the same <code>topic</code> and cache <code>id</code>.</p>
<pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">MeshCall</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">MeshCall</span><span class="hl-1">.</span><span class="hl-0">flush</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-5">topic:</span><span class="hl-1"> </span><span class="hl-2">&#39;my.demo.function&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-5">options:</span><span class="hl-1"> { </span><span class="hl-5">id:</span><span class="hl-1"> </span><span class="hl-2">&#39;myid123&#39;</span><span class="hl-1"> },</span><br/><span class="hl-1">});</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details>
<br/>
<a id="md:meshflow--transactional-workflow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">MeshFlow | Transactional Workflow<a href="#md:meshflow--transactional-workflow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p><a href="https://hotmeshio.github.io/sdk-typescript/classes/services_meshflow.MeshFlow.html">MeshFlow</a> is a drop-in, serverless replacement for <a href="https://temporal.io">Temporal.io</a>.</p>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Orchestrate unpredictable activities <small>[more]</small></summary>
<a id="md:proxy-activities" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Proxy Activities<a href="#md:proxy-activities" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>When an endpoint is unpredictable, use <code>proxyActivities</code>. HotMesh will retry as necessary until the call succeeds. This example demonstrates a workflow that greets a user in both English and Spanish. Even though both activities throw random errors, the workflow always returns a successful result.</p>
<ol>
<li>
<p>Start by defining <strong>activities</strong>. Note how each throws an error 50% of the time.</p>
<pre><code class="typescript"><span class="hl-3">//activities.ts</span><br/><span class="hl-4">export</span><span class="hl-1"> </span><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">greet</span><span class="hl-1">(</span><span class="hl-5">name</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;</span><span class="hl-7">string</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">  </span><span class="hl-4">if</span><span class="hl-1"> (</span><span class="hl-5">Math</span><span class="hl-1">.</span><span class="hl-0">random</span><span class="hl-1">() &gt; </span><span class="hl-8">0.5</span><span class="hl-1">) </span><span class="hl-4">throw</span><span class="hl-1"> </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">Error</span><span class="hl-1">(</span><span class="hl-2">&#39;Random error&#39;</span><span class="hl-1">);</span><br/><span class="hl-1">  </span><span class="hl-4">return</span><span class="hl-1"> </span><span class="hl-2">`Hello, </span><span class="hl-6">${</span><span class="hl-5">name</span><span class="hl-6">}</span><span class="hl-2">!`</span><span class="hl-1">;</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-4">export</span><span class="hl-1"> </span><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">saludar</span><span class="hl-1">(</span><span class="hl-5">nombre</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;</span><span class="hl-7">string</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">  </span><span class="hl-4">if</span><span class="hl-1"> (</span><span class="hl-5">Math</span><span class="hl-1">.</span><span class="hl-0">random</span><span class="hl-1">() &gt; </span><span class="hl-8">0.5</span><span class="hl-1">) </span><span class="hl-4">throw</span><span class="hl-1"> </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">Error</span><span class="hl-1">(</span><span class="hl-2">&#39;Random error&#39;</span><span class="hl-1">);</span><br/><span class="hl-1">  </span><span class="hl-4">return</span><span class="hl-1"> </span><span class="hl-2">`¬°Hola, </span><span class="hl-6">${</span><span class="hl-5">nombre</span><span class="hl-6">}</span><span class="hl-2">!`</span><span class="hl-1">;</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Define the <strong>workflow</strong> logic. Include conditional branching, loops, etc to control activity execution. It's vanilla JavaScript written in your own coding style. The only requirement is to use <code>proxyActivities</code>, ensuring your activities are executed with HotMesh's durability wrapper.</p>
<pre><code class="typescript"><span class="hl-3">//workflows.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">workflow</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> </span><span class="hl-6">*</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">activities</span><span class="hl-1"> </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./activities&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> { </span><span class="hl-9">greet</span><span class="hl-1">, </span><span class="hl-9">saludar</span><span class="hl-1"> } = </span><span class="hl-5">workflow</span><br/><span class="hl-1">  .</span><span class="hl-0">proxyActivities</span><span class="hl-1">&lt;</span><span class="hl-6">typeof</span><span class="hl-1"> </span><span class="hl-5">activities</span><span class="hl-1">&gt;({</span><br/><span class="hl-1">    </span><span class="hl-5">activities</span><br/><span class="hl-1">  });</span><br/><br/><span class="hl-4">export</span><span class="hl-1"> </span><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">example</span><span class="hl-1">(</span><span class="hl-5">name</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;[</span><span class="hl-7">string</span><span class="hl-1">, </span><span class="hl-7">string</span><span class="hl-1">]&gt; {</span><br/><span class="hl-1">  </span><span class="hl-4">return</span><span class="hl-1"> </span><span class="hl-7">Promise</span><span class="hl-1">.</span><span class="hl-0">all</span><span class="hl-1">([</span><br/><span class="hl-1">    </span><span class="hl-0">greet</span><span class="hl-1">(</span><span class="hl-5">name</span><span class="hl-1">),</span><br/><span class="hl-1">    </span><span class="hl-0">saludar</span><span class="hl-1">(</span><span class="hl-5">name</span><span class="hl-1">)</span><br/><span class="hl-1">  ]);</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Instance a HotMesh <strong>client</strong> to invoke the workflow.</p>
<pre><code class="typescript"><span class="hl-3">//client.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1">, </span><span class="hl-5">HotMesh</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">run</span><span class="hl-1">(): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;</span><span class="hl-7">string</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">  </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">client</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">Client</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">      }</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  });</span><br/><br/><span class="hl-1">  </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">handle</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">client</span><span class="hl-1">.</span><span class="hl-5">workflow</span><span class="hl-1">.</span><span class="hl-0">start</span><span class="hl-1">&lt;[</span><span class="hl-7">string</span><span class="hl-1">,</span><span class="hl-7">string</span><span class="hl-1">]&gt;({</span><br/><span class="hl-1">    </span><span class="hl-5">args:</span><span class="hl-1"> [</span><span class="hl-2">&#39;HotMesh&#39;</span><span class="hl-1">],</span><br/><span class="hl-1">    </span><span class="hl-5">taskQueue:</span><span class="hl-1"> </span><span class="hl-2">&#39;default&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">workflowName:</span><span class="hl-1"> </span><span class="hl-2">&#39;example&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">workflowId:</span><span class="hl-1"> </span><span class="hl-5">HotMesh</span><span class="hl-1">.</span><span class="hl-0">guid</span><span class="hl-1">()</span><br/><span class="hl-1">  });</span><br/><br/><span class="hl-1">  </span><span class="hl-4">return</span><span class="hl-1"> </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">handle</span><span class="hl-1">.</span><span class="hl-0">result</span><span class="hl-1">();</span><br/><span class="hl-1">  </span><span class="hl-3">//returns [&#39;Hello HotMesh&#39;, &#39;¬°Hola, HotMesh!&#39;]</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Finally, create a <strong>worker</strong> and link the workflow function. Workers listen for tasks on their assigned task queue and invoke the workflow function each time they receive an event.</p>
<pre><code class="typescript"><span class="hl-3">//worker.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">worker</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> </span><span class="hl-6">*</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">workflows</span><span class="hl-1"> </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./workflows&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">run</span><span class="hl-1">() {</span><br/><span class="hl-1">  </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">worker</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">Worker</span><span class="hl-1">.</span><span class="hl-0">create</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">      }</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-5">taskQueue:</span><span class="hl-1"> </span><span class="hl-2">&#39;default&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">workflow:</span><span class="hl-1"> </span><span class="hl-5">workflows</span><span class="hl-1">.</span><span class="hl-5">example</span><span class="hl-1">,</span><br/><span class="hl-1">  });</span><br/><br/><span class="hl-1">  </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">worker</span><span class="hl-1">.</span><span class="hl-0">run</span><span class="hl-1">();</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Pause and wait for a signal <small>[more]</small></summary>
<a id="md:wait-for-signal" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Wait for Signal<a href="#md:wait-for-signal" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Pause a function and only awaken when a matching signal is received from the outide.</p>
<ol>
<li>
<p>Define the <strong>workflow</strong> logic. This one waits for the <code>my-sig-nal</code> signal, returning the signal payload (<code>{ hello: 'world' }</code>) when it eventually arrives. Interleave additional logic to meet your use case.</p>
<pre><code class="typescript"><span class="hl-3">//waitForWorkflow.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">workflow</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">export</span><span class="hl-1"> </span><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">waitForExample</span><span class="hl-1">(): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;{</span><span class="hl-5">hello</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">}&gt; {</span><br/><span class="hl-1">  </span><span class="hl-4">return</span><span class="hl-1"> </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">workflow</span><span class="hl-1">.</span><span class="hl-0">waitFor</span><span class="hl-1">&lt;{</span><span class="hl-5">hello</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">}&gt;(</span><span class="hl-2">&#39;my-sig-nal&#39;</span><span class="hl-1">);</span><br/><span class="hl-1">  </span><span class="hl-3">//continue processing, use the payload, etc...</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Instance a HotMesh <strong>client</strong> and start a workflow. Use a custom workflow ID (<code>myWorkflow123</code>).</p>
<pre><code class="typescript"><span class="hl-3">//client.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1">, </span><span class="hl-5">HotMesh</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">run</span><span class="hl-1">(): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;</span><span class="hl-7">string</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">  </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">client</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">Client</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">      }</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  });</span><br/><br/><span class="hl-1">  </span><span class="hl-3">//start a workflow; it will immediately pause</span><br/><span class="hl-1">  </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">client</span><span class="hl-1">.</span><span class="hl-5">workflow</span><span class="hl-1">.</span><span class="hl-0">start</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">args:</span><span class="hl-1"> [</span><span class="hl-2">&#39;HotMesh&#39;</span><span class="hl-1">],</span><br/><span class="hl-1">    </span><span class="hl-5">taskQueue:</span><span class="hl-1"> </span><span class="hl-2">&#39;default&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">workflowName:</span><span class="hl-1"> </span><span class="hl-2">&#39;waitForExample&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">workflowId:</span><span class="hl-1"> </span><span class="hl-2">&#39;myWorkflow123&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">await:</span><span class="hl-1"> </span><span class="hl-6">false</span><span class="hl-1">,</span><br/><span class="hl-1">  });</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Create a <strong>worker</strong> and link the <code>waitForExample</code> workflow function.</p>
<pre><code class="typescript"><span class="hl-3">//worker.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Worker</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> </span><span class="hl-6">*</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">workflows</span><span class="hl-1"> </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./waitForWorkflow&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">run</span><span class="hl-1">() {</span><br/><span class="hl-1">  </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">worker</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">Worker</span><span class="hl-1">.</span><span class="hl-0">create</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">      }</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-5">taskQueue:</span><span class="hl-1"> </span><span class="hl-2">&#39;default&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">workflow:</span><span class="hl-1"> </span><span class="hl-5">workflows</span><span class="hl-1">.</span><span class="hl-5">waitForExample</span><span class="hl-1">,</span><br/><span class="hl-1">  });</span><br/><br/><span class="hl-1">  </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">worker</span><span class="hl-1">.</span><span class="hl-0">run</span><span class="hl-1">();</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Send a signal to awaken the paused function; await the function result.</p>
<pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">client</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">Client</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-3">//awaken the function by sending a signal</span><br/><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">client</span><span class="hl-1">.</span><span class="hl-0">signal</span><span class="hl-1">(</span><span class="hl-2">&#39;my-sig-nal&#39;</span><span class="hl-1">, { </span><span class="hl-5">hello:</span><span class="hl-1"> </span><span class="hl-2">&#39;world&#39;</span><span class="hl-1"> });</span><br/><br/><span class="hl-3">//get the workflow handle and await the result</span><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">handle</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">client</span><span class="hl-1">.</span><span class="hl-0">getHandle</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-5">taskQueue:</span><span class="hl-1"> </span><span class="hl-2">&#39;default&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">workflowId:</span><span class="hl-1"> </span><span class="hl-2">&#39;myWorkflow123&#39;</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">result</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">handle</span><span class="hl-1">.</span><span class="hl-0">result</span><span class="hl-1">();</span><br/><span class="hl-3">//returns { hello: &#39;world&#39; }</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Wait for multiple signals (collation) <small>[more]</small></summary>
<a id="md:collate-multiple-signals" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Collate Multiple Signals<a href="#md:collate-multiple-signals" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Use a standard <code>Promise</code> to collate and cache multiple signals. HotMesh will only awaken once <strong>all</strong> signals have arrived. HotMesh will track up to 25 concurrent signals.</p>
<ol>
<li>
<p>Update the <strong>workflow</strong> logic to await two signals using a promise: <code>my-sig-nal-1</code> and <code>my-sig-nal-2</code>. Add additional logic to meet your use case.</p>
<pre><code class="typescript"><span class="hl-3">//waitForWorkflows.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">workflow</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">export</span><span class="hl-1"> </span><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">waitForExample</span><span class="hl-1">(): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;[</span><span class="hl-7">boolean</span><span class="hl-1">, </span><span class="hl-7">number</span><span class="hl-1">]&gt; {</span><br/><span class="hl-1">  </span><span class="hl-6">const</span><span class="hl-1"> [</span><span class="hl-9">s1</span><span class="hl-1">, </span><span class="hl-9">s2</span><span class="hl-1">] = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-7">Promise</span><span class="hl-1">.</span><span class="hl-0">all</span><span class="hl-1">([</span><br/><span class="hl-1">    </span><span class="hl-5">workflow</span><span class="hl-1">.</span><span class="hl-0">waitFor</span><span class="hl-1">&lt;</span><span class="hl-7">boolean</span><span class="hl-1">&gt;(</span><span class="hl-2">&#39;my-sig-nal-1&#39;</span><span class="hl-1">),</span><br/><span class="hl-1">    </span><span class="hl-5">workflow</span><span class="hl-1">.</span><span class="hl-0">waitFor</span><span class="hl-1">&lt;</span><span class="hl-7">number</span><span class="hl-1">&gt;(</span><span class="hl-2">&#39;my-sig-nal-2&#39;</span><span class="hl-1">)</span><br/><span class="hl-1">  ]);</span><br/><span class="hl-1">  </span><span class="hl-3">//do something with the signal payloads (s1, s2)</span><br/><span class="hl-1">  </span><span class="hl-4">return</span><span class="hl-1"> [</span><span class="hl-5">s1</span><span class="hl-1">, </span><span class="hl-5">s2</span><span class="hl-1">];</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Send <strong>two</strong> signals to awaken the paused function.</p>
<pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">client</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">Client</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-3">//send 2 signals to awaken the function; order is unimportant</span><br/><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">client</span><span class="hl-1">.</span><span class="hl-0">signal</span><span class="hl-1">(</span><span class="hl-2">&#39;my-sig-nal-2&#39;</span><span class="hl-1">, </span><span class="hl-8">12345</span><span class="hl-1">);</span><br/><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">client</span><span class="hl-1">.</span><span class="hl-0">signal</span><span class="hl-1">(</span><span class="hl-2">&#39;my-sig-nal-1&#39;</span><span class="hl-1">, </span><span class="hl-6">true</span><span class="hl-1">);</span><br/><br/><span class="hl-3">//get the workflow handle and await the collated result</span><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">handle</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">client</span><span class="hl-1">.</span><span class="hl-0">getHandle</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-5">taskQueue:</span><span class="hl-1"> </span><span class="hl-2">&#39;default&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">workflowId:</span><span class="hl-1"> </span><span class="hl-2">&#39;myWorkflow123&#39;</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">result</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">handle</span><span class="hl-1">.</span><span class="hl-0">result</span><span class="hl-1">();</span><br/><span class="hl-3">//returns [true, 12345]</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Create a recurring, cyclical workflow <small>[more]</small></summary>
<a id="md:cyclical-workflow" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Cyclical Workflow<a href="#md:cyclical-workflow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>This example calls an activity and then sleeps for a week. It runs indefinitely until it's manually stopped. It takes advantage of durable execution and can safely sleep for months or years.</p>
<blockquote>
<p>Container restarts have no impact on actively executing workflows as all state is retained in the backend.</p>
</blockquote>
<ol>
<li>
<p>Define the <strong>workflow</strong> logic. This one calls a legacy <code>statusDiagnostic</code> function once a week.</p>
<pre><code class="typescript"><span class="hl-3">//recurringWorkflow.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">workflow</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> </span><span class="hl-6">*</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">activities</span><span class="hl-1"> </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./activities&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> { </span><span class="hl-9">statusDiagnostic</span><span class="hl-1"> } = </span><span class="hl-5">workflow</span><br/><span class="hl-1">  .</span><span class="hl-0">proxyActivities</span><span class="hl-1">&lt;</span><span class="hl-6">typeof</span><span class="hl-1"> </span><span class="hl-5">activities</span><span class="hl-1">&gt;({</span><br/><span class="hl-1">    </span><span class="hl-5">activities</span><br/><span class="hl-1">  });</span><br/><br/><span class="hl-4">export</span><span class="hl-1"> </span><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">recurringExample</span><span class="hl-1">(</span><span class="hl-5">someValue</span><span class="hl-1">: </span><span class="hl-7">number</span><span class="hl-1">): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;</span><span class="hl-7">void</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">  </span><span class="hl-4">do</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-0">statusDiagnostic</span><span class="hl-1">(</span><span class="hl-5">someValue</span><span class="hl-1">);</span><br/><span class="hl-1">  } </span><span class="hl-4">while</span><span class="hl-1"> (</span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">workflow</span><span class="hl-1">.</span><span class="hl-0">sleepFor</span><span class="hl-1">(</span><span class="hl-2">&#39;1 week&#39;</span><span class="hl-1">));</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Instance a HotMesh <strong>client</strong> and start a workflow. Assign a custom workflow ID (e.g., <code>myRecurring123</code>) if the workflow should be idempotent.</p>
<pre><code class="typescript"><span class="hl-3">//client.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1">, </span><span class="hl-5">HotMesh</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">run</span><span class="hl-1">(): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;</span><span class="hl-7">string</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">  </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">client</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">Client</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">      }</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  });</span><br/><br/><span class="hl-1">  </span><span class="hl-3">//start a workflow; it will immediately pause</span><br/><span class="hl-1">  </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">client</span><span class="hl-1">.</span><span class="hl-5">workflow</span><span class="hl-1">.</span><span class="hl-0">start</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">args:</span><span class="hl-1"> [</span><span class="hl-8">55</span><span class="hl-1">],</span><br/><span class="hl-1">    </span><span class="hl-5">taskQueue:</span><span class="hl-1"> </span><span class="hl-2">&#39;default&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">workflowName:</span><span class="hl-1"> </span><span class="hl-2">&#39;recurringExample&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">workflowId:</span><span class="hl-1"> </span><span class="hl-2">&#39;myRecurring123&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">await:</span><span class="hl-1"> </span><span class="hl-6">false</span><span class="hl-1">,</span><br/><span class="hl-1">  });</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Create a <strong>worker</strong> and link the <code>recurringExample</code> workflow function.</p>
<pre><code class="typescript"><span class="hl-3">//worker.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Worker</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> </span><span class="hl-6">*</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">workflows</span><span class="hl-1"> </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./recurringWorkflow&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1"> </span><span class="hl-0">run</span><span class="hl-1">() {</span><br/><span class="hl-1">  </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">worker</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">Worker</span><span class="hl-1">.</span><span class="hl-0">create</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">      }</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-5">taskQueue:</span><span class="hl-1"> </span><span class="hl-2">&#39;default&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">workflow:</span><span class="hl-1"> </span><span class="hl-5">workflows</span><span class="hl-1">.</span><span class="hl-5">recurringExample</span><span class="hl-1">,</span><br/><span class="hl-1">  });</span><br/><br/><span class="hl-1">  </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">worker</span><span class="hl-1">.</span><span class="hl-0">run</span><span class="hl-1">();</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Cancel the recurring workflow (<code>myRecurring123</code>) by calling <code>interrupt</code>.</p>
<pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">client</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">Client</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-5">connection:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-3">//get the workflow handle and interrupt it</span><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">handle</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">client</span><span class="hl-1">.</span><span class="hl-0">getHandle</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-5">taskQueue:</span><span class="hl-1"> </span><span class="hl-2">&#39;default&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">workflowId:</span><span class="hl-1"> </span><span class="hl-2">&#39;myRecurring123&#39;</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">result</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">handle</span><span class="hl-1">.</span><span class="hl-0">interrupt</span><span class="hl-1">();</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details>
<br/>
<a id="md:meshdata--transactional-analytics" class="tsd-anchor"></a><h2 class="tsd-anchor-link">MeshData | Transactional Analytics<a href="#md:meshdata--transactional-analytics" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p><a href="https://hotmeshio.github.io/sdk-typescript/classes/services_meshdata.MeshData.html">MeshData</a> adds analytics to transactional workflows.</p>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Create a search index <small>[more]</small></summary>
<a id="md:workflow-data-indexes" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Workflow Data Indexes<a href="#md:workflow-data-indexes" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>This example demonstrates how to define a schema and deploy an index for a 'user' entity type.</p>
<ol>
<li>
<p>Define the <strong>schema</strong> for the <code>user</code> entity. This one includes the 3 formats supported by the FT.SEARCH module: <code>TEXT</code>, <code>TAG</code> and <code>NUMERIC</code>.</p>
<pre><code class="typescript"><span class="hl-3">//schema.ts</span><br/><span class="hl-4">export</span><span class="hl-1"> </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">schema</span><span class="hl-1">: </span><span class="hl-7">Types</span><span class="hl-1">.</span><span class="hl-7">WorkflowSearchOptions</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-5">schema:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">id:</span><span class="hl-1"> { </span><span class="hl-5">type:</span><span class="hl-1"> </span><span class="hl-2">&#39;TAG&#39;</span><span class="hl-1">, </span><span class="hl-5">sortable:</span><span class="hl-1"> </span><span class="hl-6">false</span><span class="hl-1"> },</span><br/><span class="hl-1">    </span><span class="hl-5">first:</span><span class="hl-1"> { </span><span class="hl-5">type:</span><span class="hl-1"> </span><span class="hl-2">&#39;TEXT&#39;</span><span class="hl-1">, </span><span class="hl-5">sortable:</span><span class="hl-1"> </span><span class="hl-6">false</span><span class="hl-1">, </span><span class="hl-5">nostem:</span><span class="hl-1"> </span><span class="hl-6">true</span><span class="hl-1"> },</span><br/><span class="hl-1">    </span><span class="hl-5">active:</span><span class="hl-1"> { </span><span class="hl-5">type:</span><span class="hl-1"> </span><span class="hl-2">&#39;TAG&#39;</span><span class="hl-1">, </span><span class="hl-5">sortable:</span><span class="hl-1"> </span><span class="hl-6">false</span><span class="hl-1"> },</span><br/><span class="hl-1">    </span><span class="hl-5">created:</span><span class="hl-1"> { </span><span class="hl-5">type:</span><span class="hl-1"> </span><span class="hl-2">&#39;NUMERIC&#39;</span><span class="hl-1">, </span><span class="hl-5">sortable:</span><span class="hl-1"> </span><span class="hl-6">true</span><span class="hl-1"> },</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-5">index:</span><span class="hl-1"> </span><span class="hl-2">&#39;user&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">prefix:</span><span class="hl-1"> [</span><span class="hl-2">&#39;user&#39;</span><span class="hl-1">],</span><br/><span class="hl-1">};</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Create the index upon server startup. This one initializes the 'user' index, using the schema defined in the previous step. It's OK to call <code>createSearchIndex</code> multiple times; it will only create the index if it doesn't already exist.</p>
<pre><code class="typescript"><span class="hl-3">//server.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">MeshData</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">schema</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./schema&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">meshData</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">MeshData</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-5">schema</span><span class="hl-1">,</span><br/><span class="hl-1">);</span><br/><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">meshData</span><span class="hl-1">.</span><span class="hl-0">createSearchIndex</span><span class="hl-1">(</span><span class="hl-2">&#39;user&#39;</span><span class="hl-1">, { </span><span class="hl-5">namespace:</span><span class="hl-1"> </span><span class="hl-2">&#39;meshdata&#39;</span><span class="hl-1"> });</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Create an indexed, searchable record <small>[more]</small></summary>
<a id="md:workflow-record-data" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Workflow Record Data<a href="#md:workflow-record-data" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>This example demonstrates how to create a 'user' workflow backed by the searchable schema from the prior example.</p>
<ol>
<li>
<p>Call MeshData <code>connect</code> to initialize a 'user' entity <em>worker</em>. It references a target worker function which will run the workflow. Data fields that are documented in the schema (like <code>active</code>) will be automatically indexed when set on the workflow record.</p>
<pre><code class="typescript"><span class="hl-3">//connect.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">MeshData</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">schema</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./schema&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">export</span><span class="hl-1"> </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-0">connectUserWorker</span><span class="hl-1"> = </span><span class="hl-6">async</span><span class="hl-1"> (): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;</span><span class="hl-7">void</span><span class="hl-1">&gt; </span><span class="hl-6">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">meshData</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">MeshData</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://  usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">      }</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-5">schema</span><span class="hl-1">,</span><br/><span class="hl-1">  );</span><br/><br/><span class="hl-1">  </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">meshData</span><span class="hl-1">.</span><span class="hl-0">connect</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">entity:</span><span class="hl-1"> </span><span class="hl-2">&#39;user&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-0">target</span><span class="hl-5">:</span><span class="hl-1"> </span><span class="hl-6">async</span><span class="hl-1"> </span><span class="hl-6">function</span><span class="hl-1">(</span><span class="hl-5">name</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;</span><span class="hl-7">string</span><span class="hl-1">&gt; {</span><br/><span class="hl-1">      </span><span class="hl-3">//add custom, searchable data (`active`) and return</span><br/><span class="hl-1">      </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">search</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">MeshData</span><span class="hl-1">.</span><span class="hl-5">workflow</span><span class="hl-1">.</span><span class="hl-0">search</span><span class="hl-1">();</span><br/><span class="hl-1">      </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">search</span><span class="hl-1">.</span><span class="hl-0">set</span><span class="hl-1">(</span><span class="hl-2">&#39;active&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;yes&#39;</span><span class="hl-1">);</span><br/><span class="hl-1">      </span><span class="hl-4">return</span><span class="hl-1"> </span><span class="hl-2">`Welcome, </span><span class="hl-6">${</span><span class="hl-5">name</span><span class="hl-6">}</span><span class="hl-2">.`</span><span class="hl-1">;</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> { </span><span class="hl-5">namespace:</span><span class="hl-1"> </span><span class="hl-2">&#39;meshdata&#39;</span><span class="hl-1"> },</span><br/><span class="hl-1">  });</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Wire up the worker at server startup, so it's ready to process incoming requests.</p>
<pre><code class="typescript"><span class="hl-3">//server.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">connectUserWorker</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./connect&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-0">connectUserWorker</span><span class="hl-1">();</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Call MeshData <code>exec</code> to create a 'user' workflow. Searchable data can be set throughout the workflow's lifecycle. This one initializes the workflow with 3 data fields: <code>id</code>, <code>name</code> and <code>timestamp</code>. <em>An additional data field (<code>active</code>) is set within the workflow function in order to demonstrate both mechanisms for reading/writing data to a workflow.</em></p>
<pre><code class="typescript"><span class="hl-3">//exec.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">MeshData</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">meshData</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">MeshData</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-5">schema</span><span class="hl-1">,</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-4">export</span><span class="hl-1"> </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-0">newUser</span><span class="hl-1"> = </span><span class="hl-6">async</span><span class="hl-1"> (</span><span class="hl-5">id</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">, </span><span class="hl-5">name</span><span class="hl-1">: </span><span class="hl-7">string</span><span class="hl-1">): </span><span class="hl-7">Promise</span><span class="hl-1">&lt;</span><span class="hl-7">string</span><span class="hl-1">&gt; </span><span class="hl-6">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">response</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">meshData</span><span class="hl-1">.</span><span class="hl-0">exec</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">entity:</span><span class="hl-1"> </span><span class="hl-2">&#39;user&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">args:</span><span class="hl-1"> [</span><span class="hl-5">name</span><span class="hl-1">],</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">ttl:</span><span class="hl-1"> </span><span class="hl-2">&#39;infinity&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-5">id</span><span class="hl-1">,</span><br/><span class="hl-1">      </span><span class="hl-5">search:</span><span class="hl-1"> {</span><br/><span class="hl-1">        </span><span class="hl-5">data:</span><span class="hl-1"> { </span><span class="hl-5">id</span><span class="hl-1">, </span><span class="hl-5">name</span><span class="hl-1">, </span><span class="hl-5">timestamp:</span><span class="hl-1"> </span><span class="hl-5">Date</span><span class="hl-1">.</span><span class="hl-0">now</span><span class="hl-1">() }</span><br/><span class="hl-1">      },</span><br/><span class="hl-1">      </span><span class="hl-5">namespace:</span><span class="hl-1"> </span><span class="hl-2">&#39;meshdata&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">  });</span><br/><span class="hl-1">  </span><span class="hl-4">return</span><span class="hl-1"> </span><span class="hl-5">response</span><span class="hl-1">;</span><br/><span class="hl-1">};</span>
</code><button type="button">Copy</button></pre>

</li>
<li>
<p>Call the <code>newUser</code> function to create a searchable 'user' record.</p>
<pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">newUser</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./exec&#39;</span><span class="hl-1">;</span><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">response</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-0">newUser</span><span class="hl-1">(</span><span class="hl-2">&#39;jim123&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;James&#39;</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Fetch record data <small>[more]</small></summary>
<a id="md:read-record-data" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Read Record Data<a href="#md:read-record-data" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>This example demonstrates how to read data fields directly from a workflow.</p>
<ol>
<li>
<p>Read data fields directly from the <em>jimbo123</em> 'user' record.</p>
<pre><code class="typescript"><span class="hl-3">//read.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">MeshData</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">schema</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./schema&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">meshData</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">MeshData</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-5">schema</span><span class="hl-1">,</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">data</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">meshData</span><span class="hl-1">.</span><span class="hl-0">get</span><span class="hl-1">(</span><br/><span class="hl-1">  </span><span class="hl-2">&#39;user&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-2">&#39;jimbo123&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  { </span><br/><span class="hl-1">    </span><span class="hl-5">fields:</span><span class="hl-1"> [</span><span class="hl-2">&#39;id&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;name&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;timestamp&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;active&#39;</span><span class="hl-1">],</span><br/><span class="hl-1">    </span><span class="hl-5">namespace:</span><span class="hl-1"> </span><span class="hl-2">&#39;meshdata&#39;</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details> 
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Search record data <small>[more]</small></summary>
<a id="md:query-record-data" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Query Record Data<a href="#md:query-record-data" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>This example demonstrates how to search for those workflows where a given condition exists in the data. This one searches for active users. <em>NOTE: The native Redis FT.SEARCH syntax and SQL are currently supported. The JSON abstraction shown here is a convenience method for straight-forward, one-dimensional queries.</em></p>
<ol>
<li>
<p>Search for active users (where the value of the <code>active</code> field is <code>yes</code>).</p>
<pre><code class="typescript"><span class="hl-3">//read.ts</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">MeshData</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;@hotmeshio/hotmesh&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">schema</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;./schema&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">meshData</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">MeshData</span><span class="hl-1">({</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-5">schema</span><span class="hl-1">,</span><br/><span class="hl-1">);</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">results</span><span class="hl-1"> = </span><span class="hl-4">await</span><span class="hl-1"> </span><span class="hl-5">meshData</span><span class="hl-1">.</span><span class="hl-0">findWhere</span><span class="hl-1">(</span><span class="hl-2">&#39;user&#39;</span><span class="hl-1">, {</span><br/><span class="hl-1">  </span><span class="hl-5">query:</span><span class="hl-1"> [{ </span><span class="hl-5">field:</span><span class="hl-1"> </span><span class="hl-2">&#39;active&#39;</span><span class="hl-1">, </span><span class="hl-5">is:</span><span class="hl-1"> </span><span class="hl-2">&#39;=&#39;</span><span class="hl-1">, </span><span class="hl-5">value:</span><span class="hl-1"> </span><span class="hl-2">&#39;yes&#39;</span><span class="hl-1"> }],</span><br/><span class="hl-1">  </span><span class="hl-5">limit:</span><span class="hl-1"> { </span><span class="hl-5">start:</span><span class="hl-1"> </span><span class="hl-8">0</span><span class="hl-1">, </span><span class="hl-5">size:</span><span class="hl-1"> </span><span class="hl-8">100</span><span class="hl-1"> },</span><br/><span class="hl-1">  </span><span class="hl-5">return:</span><span class="hl-1"> [</span><span class="hl-2">&#39;id&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;name&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;timestamp&#39;</span><span class="hl-1">, </span><span class="hl-2">&#39;active&#39;</span><span class="hl-1">]</span><br/><span class="hl-1">});</span>
</code><button type="button">Copy</button></pre>

</li>
</ol>
</details> 
<br/>
<a id="md:connect" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Connect<a href="#md:connect" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>HotMesh is pluggable and ships with support for Postgres (pg) and Redis (ioredis/redis). NATS is also supported for PubSub for extended patterns.</p>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Postgres <small>[more]</small></summary>
<a id="md:connect-postgres-client" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Connect Postgres Client<a href="#md:connect-postgres-client" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">PostgresClient</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-3">//provide these credentials to HotMesh</span><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">connection</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">PostgresClient</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">};</span><br/>
</code><button type="button">Copy</button></pre>

<a id="md:connect-postgres-pool" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Connect Postgres Pool<a href="#md:connect-postgres-pool" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Pool connections are recommended for high-throughput applications. The pool will manage connections and automatically handle connection pooling.</p>
<pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Pool</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">PostgresPool</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">PostgresPoolClient</span><span class="hl-1"> = </span><span class="hl-6">new</span><span class="hl-1"> </span><span class="hl-0">PostgresPool</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-3">//provide these credentials to HotMesh</span><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">connection</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">PostgresPoolClient</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">options:</span><span class="hl-1"> {}</span><br/><span class="hl-1">};</span>
</code><button type="button">Copy</button></pre>

</details>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">Redis <small>[more]</small></summary>
<a id="md:redisioredis" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Redis/IORedis<a href="#md:redisioredis" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> </span><span class="hl-6">*</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Redis</span><span class="hl-1"> </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;redis&#39;</span><span class="hl-1">;</span><br/><span class="hl-3">//OR `import Redis from &#39;ioredis&#39;;`</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">connection</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Redis</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">url:</span><span class="hl-1"> </span><span class="hl-2">&#39;redis://:your_password@localhost:6379&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">};</span>
</code><button type="button">Copy</button></pre>

</details>
<details style="padding: .5em">
  <summary style="font-size:1.25em;">NATS <small>[more]</small></summary>
<a id="md:nats-pubsub" class="tsd-anchor"></a><h3 class="tsd-anchor-link">NATS PubSub<a href="#md:nats-pubsub" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Add NATS for improved PubSub support, including patterned subscriptions. Note the explicit channel subscription in the example below. <em>The NATS provider supports version 2.0 of the NATS client (the latest version). See ./package.json for details.</em></p>
<pre><code class="typescript"><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">Client</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;pg&#39;</span><span class="hl-1">;</span><br/><span class="hl-4">import</span><span class="hl-1"> { </span><span class="hl-5">connect</span><span class="hl-1"> </span><span class="hl-4">as</span><span class="hl-1"> </span><span class="hl-5">NATS</span><span class="hl-1"> } </span><span class="hl-4">from</span><span class="hl-1"> </span><span class="hl-2">&#39;nats&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-9">connection</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-5">store:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-5">stream:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-5">Postgres</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-5">connectionString:</span><span class="hl-1"> </span><span class="hl-2">&#39;postgresql://usr:pwd@localhost:5432/db&#39;</span><span class="hl-1">,</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-5">sub:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-5">class:</span><span class="hl-1"> </span><span class="hl-9">NATS</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-5">options:</span><span class="hl-1"> { </span><span class="hl-5">servers:</span><span class="hl-1"> [</span><span class="hl-2">&#39;nats:4222&#39;</span><span class="hl-1">] }</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">};</span>
</code><button type="button">Copy</button></pre>

</details>
<br/>
<a id="md:metrics-and-monitoring" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Metrics and Monitoring<a href="#md:metrics-and-monitoring" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>HotMesh's <strong>OpenTelemetry</strong> output provides insight into long-running, cross-service transactions. Add an OpenTelemetry sink to any service where HotMesh is deployed and HotMesh will emit the full <strong>OpenTelemetry</strong> execution tree organized as a single, unified DAG.</p>
<p>The <strong>HotMesh Dashboard</strong> provides a detailed overview of all running workflows. It includes an LLM to simplify querying and analyzing workflow data. An example Web server with REST APIs and the Dashboard (a WebApp) is included in the <a href="https://github.com/hotmeshio/samples-typescript">samples-typescript</a> Git repo.</p>
<br/>
<a id="md:examples" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Examples<a href="#md:examples" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Refer to the <a href="https://github.com/hotmeshio/samples-typescript">hotmeshio/samples-typescript</a> Git repo for <em>tutorials</em> and instructions on deploying the <em>HotMesh Dashboard</em> for visualizing workflows and managing network health.</p>
<p>Refer to the <a href="https://github.com/hotmeshio/temporal-patterns-typescript">hotmeshio/temporal-patterns-typescript</a> Git repo for examples of common <a href="http://Temporal.io">Temporal.io</a> patterns implemented using HotMesh.</p>
<br/>
<a id="md:advanced" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Advanced<a href="#md:advanced" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The theory that underlies the architecture is applicable to any number of data storage and streaming backends: <a href="https://zenodo.org/records/12168558">A Message-Oriented Approach to Decentralized Process Orchestration</a>.</p>
<br/>
<a id="md:disclaimer" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Disclaimer<a href="#md:disclaimer" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This project is not affiliated with, endorsed by, or sponsored by Temporal Technologies, Inc. Temporal is a trademark of Temporal Technologies, Inc., and all references to Temporal and related technologies are for educational and demonstration purposes only.</p>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#md:hotmesh"><span>Hot<wbr/>Mesh</span></a><ul><li><a href="#md:features"><span>Features</span></a></li><li><a href="#md:install"><span>Install</span></a></li><li><a href="#md:learn"><span>Learn</span></a></li><li><a href="#md:meshcall--service-to-service-function-calls"><span>Mesh<wbr/>Call | <wbr/>Service-<wbr/>to-<wbr/>Service <wbr/>Function <wbr/>Calls</span></a></li><li><ul><li><a href="#md:run-a-cron"><span>Run a <wbr/>Cron</span></a></li><li><a href="#md:interrupt-a-cron"><span>Interrupt a <wbr/>Cron</span></a></li><li><a href="#md:call-a-function"><span>Call a <wbr/>Function</span></a></li><li><a href="#md:cache-a-function"><span>Cache a <wbr/>Function</span></a></li></ul></li><li><a href="#md:meshflow--transactional-workflow"><span>Mesh<wbr/>Flow | <wbr/>Transactional <wbr/>Workflow</span></a></li><li><ul><li><a href="#md:proxy-activities"><span>Proxy <wbr/>Activities</span></a></li><li><a href="#md:wait-for-signal"><span>Wait for <wbr/>Signal</span></a></li><li><a href="#md:collate-multiple-signals"><span>Collate <wbr/>Multiple <wbr/>Signals</span></a></li><li><a href="#md:cyclical-workflow"><span>Cyclical <wbr/>Workflow</span></a></li></ul></li><li><a href="#md:meshdata--transactional-analytics"><span>Mesh<wbr/>Data | <wbr/>Transactional <wbr/>Analytics</span></a></li><li><ul><li><a href="#md:workflow-data-indexes"><span>Workflow <wbr/>Data <wbr/>Indexes</span></a></li><li><a href="#md:workflow-record-data"><span>Workflow <wbr/>Record <wbr/>Data</span></a></li><li><a href="#md:read-record-data"><span>Read <wbr/>Record <wbr/>Data</span></a></li><li><a href="#md:query-record-data"><span>Query <wbr/>Record <wbr/>Data</span></a></li></ul></li><li><a href="#md:connect"><span>Connect</span></a></li><li><ul><li><a href="#md:connect-postgres-client"><span>Connect <wbr/>Postgres <wbr/>Client</span></a></li><li><a href="#md:connect-postgres-pool"><span>Connect <wbr/>Postgres <wbr/>Pool</span></a></li><li><a href="#md:redisioredis"><span>Redis/IORedis</span></a></li><li><a href="#md:nats-pubsub"><span>NATS <wbr/>Pub<wbr/>Sub</span></a></li></ul></li><li><a href="#md:metrics-and-monitoring"><span>Metrics and <wbr/>Monitoring</span></a></li><li><a href="#md:examples"><span>Examples</span></a></li><li><a href="#md:advanced"><span>Advanced</span></a></li><li><a href="#md:disclaimer"><span>Disclaimer</span></a></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="index.html" class="current"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="assets/icons.svg#icon-1"></use></svg><span>HotMesh</span></a><ul class="tsd-small-nested-navigation" id="tsd-nav-container" data-base="."><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>
